<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Class FrmAbandonmentEntries
 *
 * @since 1.0
 *
 * @package formidable-abandonment
 */

/**
 * Processing abandonment crud.
 *
 * @since 1.0
 *
 * @internal
 */
class FrmAbandonmentEntries {

	/**
	 * User uuid which generated by JS per visitor.
	 *
	 * @since 1.0
	 *
	 * @var string
	 */
	private $user_uuid;

	/**
	 * Hold the current is_draft value before update.
	 *
	 * @since 1.0
	 *
	 * @var int
	 */
	private $is_draft;

	/**
	 * FrmAbandonmentEntries constructor.
	 *
	 * @since 1.0
	 *
	 * @param string $user_uuid Generated user uuid by script from cookie.
	 * @param int    $form_id Form id.
	 * @param int    $is_draft is_draft column value.
	 *
	 * @return void
	 */
	public function __construct( $user_uuid, $form_id, $is_draft ) {
		$this->user_uuid = $user_uuid;
		$this->is_draft  = (int) $is_draft;
		$this->exclude_field_to_store( $form_id );
	}

	/**
	 * Maybe insert new abandonment entry or update them.
	 *
	 * @since 1.0
	 *
	 * @return void
	 */
	public function submit_entry() {
		$user_uuid_exist = self::get_entry_by_uuid( $this->user_uuid );

		if ( FrmProFormsHelper::saving_draft() ) {
			return;
		}

		if ( FrmAbandonmentAppHelper::IN_PROGRESS_ENTRY_STATUS === $this->is_draft && $user_uuid_exist ) {
			$this->update_entry( $user_uuid_exist, $_POST ); // phpcs:ignore WordPress.Security.NonceVerification.Missing
		} else {
			// Remove pro process entry, It will remove duplicate entry .
			remove_action( 'frm_process_entry', 'FrmProEntriesController::process_update_entry', 10 );
			$this->insert_entry();
		}
	}

	/**
	 * Return entry id by UUID.
	 *
	 * @since 1.0
	 *
	 * @param string $key      Key.
	 *
	 * @return string|false    Return `false` if the meta value does not exist.
	 */
	public static function get_entry_by_uuid( $key ) {
		$result = FrmDb::get_var(
			'frm_item_metas',
			array(
				'meta_value' => $key,
				'field_id' => 0,
			),
			'item_id'
		);

		if ( ! $result ) {
			return false;
		}

		return $result;
	}

	/**
	 * Update is_draft column to 2 "In Progress" and add a token, uuid
	 * to entry meta table after creating entry.
	 *
	 * @since 1.0
	 *
	 * @param int           $entry_id Entry id.
	 * @param int           $form_id Entry id.
	 * @param array<string> $args Contains child entry pointer.
	 *
	 * @return void
	 */
	public function after_create_abandonment_entry( $entry_id, $form_id, $args ) {
		global $wpdb;

		// Link UUID to a parent entry.
		if ( ! $args['is_child'] ) {
			self::assign_uuid_token_to_entry( $entry_id, $this->user_uuid );
		}

		$wpdb->update( $wpdb->prefix . 'frm_items', array( 'is_draft' => 2 ), array( 'id' => $entry_id ) );
	}

	/**
	 * By default in packaging the update entry is_draft column is set to 0 but
	 * we need to keep it to 2 which is an In Progress mark.
	 *
	 * @since 1.0
	 *
	 * @param array<mixed> $new_values Entry values.
	 *
	 * @return array<mixed> $new_values Updated entry values.
	 */
	public function after_update_abandonment_entry( $new_values ) {
		$entry_status = FrmEntriesHelper::DRAFT_ENTRY_STATUS === $this->is_draft ? FrmEntriesHelper::DRAFT_ENTRY_STATUS : FrmAbandonmentAppHelper::IN_PROGRESS_ENTRY_STATUS;

		$new_values['is_draft'] = $entry_status;
		return $new_values;
	}

	/**
	 * Change is_draft column to 3 "Abandoned" from 2 "In progress".
	 *
	 * @see FrmAbandonmentCronController
	 *
	 * @since 1.0
	 *
	 * @param array<object> $in_progress_entries {
	 *   Array of "in progress" entries.
	 *   @type int    $id
	 *   @type int    $form_id
	 *   @type string $name
	 * }
	 *
	 * @return void
	 */
	public static function mark_entries_abandoned( $in_progress_entries ) {
		foreach ( $in_progress_entries as $entry ) {
			FrmEntry::update(
				$entry->id,
				array(
					'is_draft' => FrmAbandonmentAppHelper::ABANDONED_ENTRY_STATUS,
					'form_id'  => $entry->form_id,
					'name'     => $entry->name,
				)
			);

			self::unlink_uuid( $entry->id );
		}
	}

	/**
	 * Get "in progress" entries.
	 *
	 * @see FrmAbandonmentCronController
	 *
	 * @since 1.0
	 *
	 * @param int    $page Page.
	 * @param int    $items_per_page Item per page.
	 * @param string $updated_at updated_at date offset.
	 *
	 * @return array<object>|null
	 */
	public static function get_in_progress_entries( $page, $items_per_page, $updated_at ) {
		global $wpdb;

		return $wpdb->get_results(
			$wpdb->prepare(
				"SELECT id,form_id,name FROM {$wpdb->prefix}frm_items WHERE is_draft=2 AND updated_at < %s ORDER BY id ASC LIMIT %d, %d",
				$updated_at,
				( $page - 1 ) * $items_per_page,
				$items_per_page
			)
		);
	}

	/**
	 * Watch on after create entry hook to unlink UUID, Token from items_meta.
	 *
	 * @since 1.0
	 *
	 * @param int $entry_id Entry ID.
	 *
	 * @return void
	 */
	public static function clean_after_submit( $entry_id ) {
		$encrypted_token = base64_decode( urldecode( FrmAppHelper::get_param( 'secret', '', 'get', 'sanitize_text_field' ) ) );
		if ( ! $encrypted_token ) {
			return;
		}

		$decrypted_value  = ( new FrmAbandonmentEncryptionHelper() )->decrypt( base64_decode( urldecode( $encrypted_token ) ) );
		if ( is_wp_error( $decrypted_value ) ) {
			return;
		}

		$token_entry_id = FrmAbandonmentAppHelper::get_entry_id_from_token( $decrypted_value );
		if ( ! $token_entry_id ) {
			return;
		}

		$current_entry_status       = (int) FrmDb::get_var( 'frm_items', array( 'id' => $entry_id ), 'is_draft' );

		if ( FrmEntriesHelper::SUBMITTED_ENTRY_STATUS === $current_entry_status && (int) $token_entry_id === (int) $entry_id ) {
			self::unlink_uuid( $entry_id );
			self::unlink_token( $entry_id );
		}
	}

	/**
	 * Unlink token and UUID from draft entries.
	 *
	 * @since 1.0
	 *
	 * @param array<string,object> $args Arguments of entry id and form.
	 *
	 * @return void
	 */
	public static function clean_after_save_draft( $args ) {
		// We only need to check the UUID whenever the form is saving draft.
		if ( ! FrmProFormsHelper::saving_draft() ) {
			return;
		}

		self::unlink_uuid( absint( $args['entry_id'] ) );
		self::unlink_token( absint( $args['entry_id'] ) );
	}

	/**
	 * Observe entry creation to let them pass to create or edit them
	 * a way to update an existing "In Progress" entry if condition met.
	 *
	 * @see FrmEntriesController::process_entry
	 *
	 * @since 1.0
	 *
	 * @param bool $allow True by default to create an entry.
	 * @param int  $form_id Form ID.
	 *
	 * @return bool Permission to new entry creation.
	 */
	public static function observe_create_entry( $allow, $form_id ) {
		if ( ! FrmAbandonmentAppHelper::is_abandonment_enabled( $form_id ) ) {
			return $allow;
		}

		$user_uuid = FrmAbandonmentAppHelper::build_uuid_with_cookie( $form_id );
		if ( ! $user_uuid ) {
			return $allow;
		}

		$user_uuid_exist = self::get_entry_by_uuid( $user_uuid );
		// If there is no entry linked to UUID and the form let the normal behavior happen.
		if ( ! $user_uuid_exist ) {
			return $allow;
		}

		return false;
	}

	/**
	 * When there is a linked "In Progress" entry to a UUID and form the entry
	 * needs to be updated instead of creating new one.
	 *
	 * @since 1.0
	 *
	 * @param array<string> $params Entry ID.
	 *
	 * @return array<string> Update params.
	 */
	public static function include_inprogress_to_update_entry( $params ) {
		if ( ! FrmAbandonmentAppHelper::is_abandonment_enabled( (int) $params['form_id'] ) ) {
			return $params;
		}

		$user_uuid = FrmAbandonmentAppHelper::build_uuid_with_cookie( (int) $params['form_id'] );
		if ( ! $user_uuid ) {
			return $params;
		}

		$user_uuid_exist = self::get_entry_by_uuid( $user_uuid );

		if ( ! $user_uuid_exist ) {
			return $params;
		}

		global $frm_vars;

		// Change action and entry ID in params.
		$params['id']     = $user_uuid_exist;
		$params['action'] = 'update';
		$params['posted_form_id'] = $params['form_id'];
		// Change the POST to update instead of create.
		$_POST['frm_action'] = 'update';
		$_POST['secret']     = urlencode( base64_encode( self::get_token( (int) $user_uuid_exist ) ) );
		$_POST['id']         = $user_uuid_exist;
		// For better compatibility update the global frm_vars.
		$frm_vars['created_entries'][ $params['form_id'] ]['entry_id'] = $user_uuid_exist;
		$frm_vars['form_params'][ $params['form_id'] ] = $params;

		if ( empty( $frm_vars['created_entries'][ $params['form_id'] ]['errors'] ) ) {
			$frm_vars['created_entries'][ $params['form_id'] ]['errors'] = array();
		}

		remove_filter( 'frm_pro_process_update_entry', 'FrmAbandonmentEntries::include_inprogress_to_update_entry', 9 );
		remove_filter( 'frm_pro_autosave_on_page_turn', 'FrmAbandonmentEntries::include_inprogress_to_update_entry', 11 );

		return $params;
	}

	/**
	 * Get Token of entry from metas, based on the entry id.
	 *
	 * @param int $entry_id The entry id to check.
	 *
	 * @return string
	 */
	public static function get_token( $entry_id ) {
		if ( 0 === $entry_id ) {
			return '';
		}

		// Search for a token linked to entry metas.
		$edit_token = self::search_entry_to_get_uuid_or_token( $entry_id, 'token' );

		if ( ! $edit_token ) {
			return '';
		}

		return ltrim( $edit_token, 'token-' );
	}

	/**
	 * Search entry for an uuid or token between zero indexed metas.
	 *
	 * @since 1.0
	 *
	 * @param int    $entry_id Entry ID.
	 * @param string $search Search meta starting string.
	 *
	 * @return string|false UUID linked to an entry or false otherwise.
	 */
	private static function search_entry_to_get_uuid_or_token( $entry_id, $search = 'uuid-' ) {
		$metas = FrmDb::get_results(
			'frm_item_metas',
			array(
				'field_id' => '0',
				'item_id'  => $entry_id,
			),
			'meta_value'
		);

		if ( ! $metas ) {
			return false;
		}

		// Find the uuid if there were more than a zero indexed meta for an entry.
		$user_uuid = false;
		foreach ( $metas as $value ) {
			if ( $search === substr( $value->meta_value, 0, 5 ) ) {
				$user_uuid = $value->meta_value;
				break;
			}
		}

		return $user_uuid;
	}

	/**
	 * Unlink UUID from item meta.
	 *
	 * @since 1.0
	 *
	 * @param int $entry_id Entry ID.
	 *
	 * @return void
	 */
	private static function unlink_uuid( $entry_id ) {
		global $wpdb;
		$wpdb->query( $wpdb->prepare( "DELETE FROM {$wpdb->prefix}frm_item_metas WHERE item_id=%d AND meta_value LIKE %s", $entry_id, $wpdb->esc_like( 'uuid-' ) . '%' ) );
	}

	/**
	 * Unlink Token from item meta.
	 *
	 * @since 1.0
	 *
	 * @param int $entry_id Entry ID.
	 *
	 * @return void
	 */
	private static function unlink_token( $entry_id ) {
		global $wpdb;
		$wpdb->query( $wpdb->prepare( "DELETE FROM {$wpdb->prefix}frm_item_metas WHERE item_id=%d AND meta_value LIKE %s", $entry_id, $wpdb->esc_like( 'token-' ) . '%' ) );
	}

	/**
	 * By default in packaging the update entry is_draft column is set to 0 but
	 * we need to keep it to 2 which is an abandonment mark.
	 *
	 * @since 1.0
	 *
	 * @param mixed        $entry_id Entry id.
	 * @param array<mixed> $values Unsanitized entry values.
	 *
	 * @return void
	 */
	private function update_entry( $entry_id, $values ) {
		$values['frm_action'] = 'update';
		$values['action']     = 'update';
		$values['id']         = $entry_id;
		$item_key             = FrmDb::get_var( 'frm_items', array( 'id' => absint( $entry_id ) ), 'item_key' );

		$values['item_key'] = $item_key;

		// Keep the entry "In Progress".
		add_filter(
			'frm_update_entry',
			/**
			 * When an entry is updated, check if it was abandoned.
			 *
			 * @param array      $entry
			 * @param string|int $updated_entry_id
			 * @param string|int $entry_id
			 * @return array
			 */
			function( $entry, $updated_entry_id ) use ( $entry_id ) {
				if ( absint( $updated_entry_id ) === absint( $entry_id ) ) {
					$entry = $this->after_update_abandonment_entry( $entry );
				}
				return $entry;
			},
			10,
			2
		);

		FrmEntry::update( $entry_id, $values );
	}

	/**
	 * Process entry to submit and remove create trigger action hook and add the abandoned trigger action and modifying is_draft.
	 *
	 * @since 1.0
	 *
	 * @return void
	 */
	private function insert_entry() {
		$_POST['action'] = 'create'; // phpcs:ignore WordPress.Security.NonceVerification.Missing

		// Remove create actions.
		remove_action( 'frm_after_create_entry', 'FrmFormActionsController::trigger_create_actions', 20 );
		add_action( 'frm_after_create_entry', array( $this, 'after_create_abandonment_entry' ), 1, 3 );

		FrmEntriesController::process_entry( '', true );
	}

	/**
	 * Sets custom value to entry.
	 *
	 * @since 1.0
	 *
	 * @param int    $entry_id Entry ID.
	 * @param string $uuid    User UUID.
	 *
	 * @return void
	 */
	private static function assign_uuid_token_to_entry( $entry_id, $uuid ) {
		$edit_token = ( new FrmAbandonmentEncryptionHelper() )->encrypt( $uuid . '-' . $entry_id );

		if ( ! is_wp_error( $edit_token ) ) {
			FrmEntryMeta::add_entry_meta( $entry_id, 0, null, 'token-' . $edit_token );
		}

		FrmEntryMeta::add_entry_meta( $entry_id, 0, null, $uuid );
	}

	/**
	 * Exclude fields to store on abandoned entry.
	 *
	 * @since 1.0
	 *
	 * @param int $form_id    Form id.
	 *
	 * @return void
	 */
	private function exclude_field_to_store( $form_id ) {
		/**
		 * Allows exclude the abandonment fields from storing.
		 *
		 * @since 1.0
		 *
		 * @param array $excluded_fields Excluded fields type.
		 */
		$excluded_fields = apply_filters( 'frm_abandonment_exclude_field_types', array( 'password', 'credit_card' ) );

		if ( ! is_array( $excluded_fields ) ) {
			_doing_it_wrong( __METHOD__, esc_html__( 'Please return an array of field types to exclude from saving.', 'formidable-abandonment' ), '1.0' );
			$excluded_fields = array( 'password', 'credit_card' );
		}

		$form_fields = FrmField::getAll(
			array(
				'fi.type not' => FrmField::no_save_fields(),
				'fi.form_id'  => (int) $form_id,
			),
			'field_order'
		);

		foreach ( $form_fields as $k => $field ) {
			if ( in_array( $field->type, $excluded_fields, true ) ) {
				unset( $_POST['item_meta'][ $field->id ] ); // phpcs:ignore WordPress.Security.NonceVerification.Missing
			}
		}

	}

}
